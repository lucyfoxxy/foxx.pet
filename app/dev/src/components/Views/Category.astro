---
import { Template } from '@Frontend';
import { PLACEHOLDER_COVER, findCoverImage } from '@Assets/covers';
import {
  findCategory,
  getIntroParagraphs,
  getNavLabelParts,
  getPageContent,
  type PageContent,
} from '@Content/siteContent';
import {
  getEntriesBySectionAndCategory,
  isAlbumEntry,
  sortEntriesByDateDesc,
  type Entry,
} from '@utils/getEntries';

interface Props {
  slug: string;
  section?: string;
}

const { slug, section } = Astro.props as Props;

const pathSegments = Astro.url.pathname.replace(/\/+$/, '').split('/').filter(Boolean);
const sectionSlug =
  section?.trim() ??
  (pathSegments.length >= 3
    ? pathSegments[1]
    : pathSegments.length >= 1
    ? pathSegments[0]
    : '');

let errorMessage: string | undefined;

if (!sectionSlug) {
  errorMessage = 'We could not resolve the requested collection.';
}

let parentPage: PageContent | undefined;

if (!errorMessage) {
  try {
    parentPage = await getPageContent(sectionSlug);
  } catch (unknownError) {
    const message =
      unknownError instanceof Error ? unknownError.message : 'Unable to load page details.';
    errorMessage = message;
  }
}

const category = parentPage ? findCategory(parentPage, slug) : undefined;

if (!errorMessage && !category) {
  errorMessage = 'There is nothing in this section yet — please check back later!';
}

const entries = !errorMessage
  ? await getEntriesBySectionAndCategory(sectionSlug, slug)
  : [];

const placeholderCover = PLACEHOLDER_COVER.src;

const toEntryHref = (entry: Entry) => {
  const parentHref = parentPage?.href?.replace(/\/+$/, '') ?? (sectionSlug ? `/${sectionSlug}` : '');
  if (isAlbumEntry(entry)) {
    const entrySlug = entry.data.slug?.trim() || entry.slug;
    const categorySegment = entry.data.category?.trim() || slug;
    const base = `${parentHref}/${categorySegment}`.replace(/\/{2,}/g, '/');
    const href = `${base}/${entrySlug}`.replace(/\/{2,}/g, '/');
    return href.endsWith('/') ? href : `${href}/`;
  }

  const segments = entry.slug.split('/').filter(Boolean);
  const entrySlug = segments[segments.length - 1] ?? entry.data.slug ?? slug;
  const categorySegment = entry.data.category?.trim() || slug;
  const base = `${parentHref}/${categorySegment}`.replace(/\/{2,}/g, '/');
  const href = `${base}/${entrySlug}`.replace(/\/{2,}/g, '/');
  return href.endsWith('/') ? href : `${href}/`;
};

const normalizedEntries = sortEntriesByDateDesc(entries)
  .map((entry) => {
    const href = toEntryHref(entry);
    if (!href) return undefined;

    const title = entry.data.title?.trim().length
      ? entry.data.title.trim()
      : entry.data.slug ?? entry.slug;
    const description = entry.data.description?.trim() ?? '';
    const date = entry.data.date;

    if (isAlbumEntry(entry)) {
      const cover = entry.data.cover?.trim()
        ? entry.data.cover.trim()
        : entry.data.items?.find((item) => item?.thumb || item?.full)?.thumb ?? placeholderCover;

      const count = typeof entry.data.count === 'number' ? entry.data.count : undefined;

      return {
        href,
        title,
        description,
        dataSlug: entry.data.slug ?? entry.slug,
        cover,
        date,
        count,
        countLabel: count !== undefined ? 'Photos' : undefined,
      };
    }
    
    const coverImage =
      entry.data.cover?.trim().length
        ? entry.data.cover.trim()
        : findCoverImage(entry.data.slug, entry.slug, entry.data.category)?.src ?? placeholderCover;

    return {
      href,
      title,
      description,
      dataSlug: entry.slug,
      cover: coverImage,
      date,
      count: undefined,
      countLabel: undefined,
    };
  })
  .filter((value): value is NonNullable<typeof value> => Boolean(value));

const hasEntries = normalizedEntries.length > 0;

const pageTitle = category?.title ?? parentPage?.title ?? 'Coming soon';
const pageDescription = category?.description ?? parentPage?.description ?? '';

const meta = { title: pageTitle, description: pageDescription };

const { icon, emoji } = parentPage ? getNavLabelParts(parentPage) : { icon: undefined, emoji: undefined };

const introParagraphs = category?.description
  ? [category.description]
  : parentPage
  ? getIntroParagraphs(parentPage)
  : [];

const backHref = parentPage ? `${parentPage.href.replace(/\/+$/, '')}/` : undefined;
const backLabel = parentPage ? `← ${parentPage.title}` : undefined;
---
<Template.Base title={pageTitle} meta={meta}>
  {backHref && backLabel ? (
    <Template.HeaderActions slot="header__actions" href={backHref} label={backLabel} />
  ) : null}

  <section class="content-section content-section--head">
    <Template.Card class="card--plain is-centered">
      <Fragment slot="head">
        <Template.TitleWithIcon
          class="card__title"
          title={pageTitle}
          icon={icon}
          emoji={emoji}
        />
      </Fragment>
      {introParagraphs.length > 0 ? (
        <Fragment slot="body">
          <div class="prose">
            {introParagraphs.map((paragraph) => (
              <p>{paragraph}</p>
            ))}
          </div>
        </Fragment>
      ) : null}
    </Template.Card>
  </section>

  {errorMessage ? (
    <section class="content-section">
      <Template.Card class=" is-centered">
        <Fragment slot="body">
          <p>{errorMessage}</p>
        </Fragment>
      </Template.Card>
    </section>
  ) : hasEntries ? (
    <section class="content-section cols-3">
      {normalizedEntries.map((entry) => (
        <Template.TileView
          href={entry.href}
          title={entry.title}
          description={entry.description}
          dataSlug={entry.dataSlug}
          cover={entry.cover}
          date={entry.date}
          count={entry.count}
          countLabel={entry.countLabel}
        />
      ))}
    </section>
  ) : (
    <section class="content-section">
      <Template.Card class=" is-centered">
        <Fragment slot="body">
          <p>No entries yet — check back soon!</p>
        </Fragment>
      </Template.Card>
    </section>
  )}
</Template.Base>
