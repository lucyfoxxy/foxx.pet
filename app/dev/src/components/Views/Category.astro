---
import BaseTemplate from '@Templates/BaseTemplate.astro';
import Card from '@Templates/Card.astro';
import TitleWithIcon from '@Templates/partials/TitleWithIcon.astro';
import HeaderActions from '@Templates/partials/HeaderActions.astro';
import { TEMPLATES } from '@Templates/templates';
import { PLACEHOLDER_COVER, findCoverImage } from '@Assets/covers';
import {
  findCategory,
  getIntroParagraphs,
  getNavLabelParts,
  getPageContent,
} from '@Content/siteContent';
import { getCollection } from 'astro:content';

interface Props {
  slug: string;
}

const { slug } = Astro.props as Props;
const pathSegments = Astro.url.pathname.replace(/\/+$/, '').split('/').filter(Boolean);
const areaSegment = pathSegments[0] ?? '';
const parentSlug = pathSegments[1] ?? '';

let errorMessage: string | undefined;
let area: 'album' | 'blog' | null = null;

if (!areaSegment || !parentSlug) {
  errorMessage = 'We could not resolve the requested collection.';
} else if (areaSegment === 'album' || areaSegment === 'blog') {
  area = areaSegment;
} else {
  errorMessage = `Unsupported content area "${areaSegment}" for subcategory overview.`;
}

let parentPage = undefined as Awaited<ReturnType<typeof getPageContent>> | undefined;
let subCategory = undefined as ReturnType<typeof findCategory> | undefined;

if (!errorMessage && parentSlug) {
  try {
    parentPage = await getPageContent(parentSlug);
  } catch (unknownError) {
    const message =
      unknownError instanceof Error ? unknownError.message : 'Unable to load page details.';
    errorMessage = message;
  }
}

if (!errorMessage && parentPage) {
  subCategory = findCategory(parentPage, slug);

  if (!subCategory) {
    errorMessage = 'There is nothing in this section yet — please check back later!';
  }
}

const { icon, emoji } = parentPage ? getNavLabelParts(parentPage) : { icon: undefined, emoji: undefined };
const introParagraphs = subCategory?.description
  ? [subCategory.description]
  : parentPage
  ? getIntroParagraphs(parentPage)
  : [];

const backHref = parentPage ? `${parentPage.href.replace(/\/+$/, '')}/` : undefined;
const backLabel = parentPage ? `← ${parentPage.title}` : undefined;

const placeholderCover = PLACEHOLDER_COVER;

// ==================
// 1) Rohdaten holen
// ==================
const albumEntriesRaw =
  !errorMessage && area === 'album'
    ? (await getCollection('album', ({ data }) => (data.category?.slug ?? '') === slug))
        .map(({ data }, index) => {
          const title = data.title ?? data.albumName ?? data.slug;
          const description = data.description ?? data.albumName ?? '';
          const startDateValue = data.startDate ? Date.parse(data.startDate) : Number.NaN;
          const hasStartDate = Number.isFinite(startDateValue);
          const formattedStartDate = hasStartDate
            ? new Intl.DateTimeFormat('en', { month: 'short', year: 'numeric' }).format(
                new Date(startDateValue),
              )
            : undefined;
          const shareKey = data.shareKey ?? undefined;
          const albumThumbnailAssetId = data.albumThumbnailAssetId ?? undefined;
          const coverUrl =
            data.coverUrl ??
            (shareKey && albumThumbnailAssetId
              ? `https://img.foxx.pet/api/assets/${albumThumbnailAssetId}/thumbnail?key=${shareKey}`
              : undefined);

          return {
            slug: data.slug,
            title,
            description,
            count: data.count,
            formattedStartDate,
            coverUrl,
            _sort: hasStartDate ? startDateValue : undefined,
            _index: index,
          };
        })
        .sort((a, b) => {
          const aHas = typeof a._sort === 'number';
          const bHas = typeof b._sort === 'number';
          if (aHas && bHas) {
            return (b._sort as number) - (a._sort as number);
          }
          if (aHas) return -1;
          if (bHas) return 1;
          return a._index - b._index;
        })
        .map(({ _sort, _index, ...entry }) => entry)
    : [];

const articleEntriesRaw =
  !errorMessage && area === 'blog'
    ? (await getCollection('blog', ({ data }) => data.category === slug))
        .map((entry) => {
          const segments = entry.slug.split('/').filter(Boolean);
          const [sectionSegment, firstRest, ...additionalRest] = segments;
          const entrySegment =
            additionalRest.length > 0
              ? additionalRest[additionalRest.length - 1]
              : firstRest ?? entry.slug;
          const categorySegment = additionalRest.length > 0 ? firstRest ?? slug : slug;
          const href = `/${areaSegment}/${sectionSegment ?? parentSlug}/${categorySegment}/${entrySegment}/`;
          const cover =
            findCoverImage(
              entry.data.heroImage,
              entry.data.slug,
              entry.slug,
              entry.data.category,
              entrySegment,
            ) ?? placeholderCover;

          return {
            slug: entry.slug,
            title: entry.data.title,
            description: entry.data.description ?? '',
            date: entry.data.date,
            cover,
            href,
          };
        })
        .sort((a, b) => {
          const aTime = a.date ? a.date.getTime() : 0;
          const bTime = b.date ? b.date.getTime() : 0;
          return bTime - aTime;
        })
    : [];

// ========================================
// 2) Normalisieren auf EIN gemeinsames Array
// ========================================
const entries =
  area === 'album'
    ? albumEntriesRaw.map(({ slug: albumSlug, title, description, count, formattedStartDate, coverUrl }) => ({
        href: `/${areaSegment}/${parentSlug}/${slug}/${albumSlug}/`,
        title,
        description,
        dataSlug: albumSlug,
        cover: coverUrl,
        date: formattedStartDate,
        count,
        countLabel: 'Photos',
      }))
    : area === 'blog'
    ? articleEntriesRaw.map(({ slug: articleSlug, title, description, date, cover, href }) => ({
        href,
        title,
        description,
        dataSlug: articleSlug,
        cover: cover.src,
        date: date,
        // hier: Anzahl der Artikel in dieser Subcategory als Count
        count: undefined,
        countLabel: undefined,
      }))
    : [];

const hasEntries = !errorMessage && entries.length > 0;

const pageTitle = subCategory?.title ?? parentPage?.title ?? 'Coming soon';
const pageDescription = subCategory?.description ?? parentPage?.description ?? '';

const meta = {
  title: pageTitle,
  description: pageDescription,
};
---

<BaseTemplate title={pageTitle} meta={meta}>
  {backHref && backLabel ? (
    <HeaderActions slot="header__actions" href={backHref} label={backLabel} />
  ) : null}

  <section class="content-section">
    <Card class="card--plain is-centered">
      <Fragment slot="head">
        <TitleWithIcon class="card__title" title={pageTitle} icon={icon} emoji={emoji} />
      </Fragment>
      {introParagraphs.length > 0 && (
        <Fragment slot="body">
          <div class="prose">
            {introParagraphs.map((paragraph) => (
              <p>{paragraph}</p>
            ))}
          </div>
        </Fragment>
      )}
    </Card>
  </section>

  {errorMessage ? (
    <section class="content-section">
      <Card class="card--ghost is-centered">
        <Fragment slot="body">
          <p>{errorMessage}</p>
        </Fragment>
      </Card>
    </section>
  ) : hasEntries ? (
    <section class="content-section cols-3">
      {entries.map((entry) => (
        <TEMPLATES.TileView
          href={entry.href}
          title={entry.title}
          description={entry.description}
          dataSlug={entry.dataSlug}
          cover={entry.cover}
          date={entry.date}
          count={entry.count}
          countLabel={entry.countLabel}
        />
      ))}
    </section>
  ) : (
    <section class="content-section">
      <Card class="card--ghost is-centered">
        <Fragment slot="body">
          <p>No entries yet — check back soon!</p>
        </Fragment>
      </Card>
    </section>
  )}
</BaseTemplate>
